
with Interfaces.Fortran; use Interfaces.Fortran;

package body Lbfgsb_F_Interface is

   type Fortran_DP_Array is array (Integer range <>) of Double_Precision;
   pragma Convention (Fortran, Fortran_DP_Array);

   type Fortran_Integer_Array is array (Integer range <>) of Integer;
   pragma Convention (Fortran, Fortran_Integer_Array);

--     type Fortran_LSave_Array is array (Integer range 1 .. 4) of Integer;
--     pragma Convention (Fortran, Fortran_LSave_Array);

--     type Fortran_ISave_Array is array (1 .. 44) of Integer;
--     pragma Convention (Fortran, Fortran_ISave_Array);

   type Fortran_DSave_Array is array (Integer range 1 .. 29) of
     Double_Precision;
   pragma Convention (Fortran, Fortran_DSave_Array);

   type Character_60 is new Fortran_Character (1 .. 60);

   function To_DP_Array (RA : Real_Float_Vector) return Fortran_DP_Array;
   function To_RF_Array (DPA : Fortran_DP_Array) return Real_Float_Vector;
--     function Zero_Array (Num_Rows : Positive) return Fortran_DP_Array;

   --  -------------------------------------------------------------------------

   --  x is a double precision array of dimension n.
   --  On entry x is an approximation to the solution.
   --  On exit x is the current approximation.
   --  nbd is an integer array of dimension n.
   --  On entry nbd represents the type of bounds imposed on the
   --  variables and must be specified by:
   --  nbd(i)=0 if x(i) is unbounded,
   --         1 if x(i) has only a lower bound,
   --         2 if x(i) has both lower and upper bounds, and
   --         3 if x(i) has only an upper bound.
   --  factr is a double precision variable specified on entry as factr >= 0
   --  The iteration stops when
   --     (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch
   --     where epsmch is the machine precision, automatically
   --     generated by the code.
   --  Typical values for factr: 10 ** 12 for low accuracy;
   --  10 ** 7 for moderate accuracy and 10 for extremely high accuracy.
   --  wa is a double precision working array of length
   --  (2mmax + 5)nmax + 12mmax^2 + 12mmax.
   --  iwa is an integer working array of length 3nmax.
   procedure setulb (m            : in Fortran_Integer;
                     x            : in out Fortran_DP_Array;
                     l, u         : in Fortran_DP_Array;  --  bounds
                     nbd          : in Fortran_Integer_Array;
                     f            : in out Double_Precision;
                     g            : in out Fortran_DP_Array;
                     factr, pgtol : in out Double_Precision;
                     wa           : in out Fortran_DP_Array;
                     iwa          : in out Fortran_Integer_Array;
                     TaskName     : in out Character_60;
                     iprint       : in Fortran_Integer;
                     csave        : in out Character_60;
                     lsave        : in out Fortran_Integer_Array;
                     isave        : in out Fortran_Integer_Array;
                     dsave        : in out Fortran_DSave_Array;
                     maxls        : in Fortran_Integer);
   pragma Import (Fortran, setulb);

   --  -------------------------------------------------------------------------

   procedure Set_Ulb (SM               : Integer;
                      SX               : in out Real_Float_Vector;
                      SL, SU           : Real_Float_Vector;  --  bounds
                      S_Nbd            : Integer_Array;
                      SF               : in out Float;
                      SG               : in out Real_Float_Vector;
                      S_Factr, S_Pgtol : in out Float;
                      S_Wa             : in out Real_Float_Vector;
                      S_Iwa            : in out Integer_Array;
                      S_Task_Name      : in out Unbounded_String;
                      S_Iprint         : Integer;
                      S_Csave          : in out Unbounded_String;
                      S_Lsave          : in out LSave_Array;
                      S_Isave          : in out Integer_Array;
                      S_Dsave          : in out DSave_Array;
                      S_Maxls          : Integer) is
      X         : Fortran_DP_Array := To_DP_Array (SX);
      F         : Double_Precision := Double_Precision (SF);
      G         : Fortran_DP_Array := To_DP_Array (SG);
      Factr     : Double_Precision := Double_Precision (S_Factr);
      Pgtol     : Double_Precision := Double_Precision (S_Pgtol);
      Wa        : Fortran_DP_Array := To_DP_Array (S_Wa);
      Iwa       : Fortran_Integer_Array := Fortran_Integer_Array (S_Iwa);
      Task_Name : Character_60 := To_Fortran (To_String (S_Task_Name));
      Csave     : Character_60 := To_Fortran (To_String (S_Csave));
      Lsave     : Fortran_Integer_Array := Fortran_Integer_Array (S_Lsave);
      Isave     : Fortran_Integer_Array := Fortran_Integer_Array (S_Isave);
      Dsave     : Fortran_DSave_Array;
   begin
      for index in Dsave'Range loop
         Dsave (index) := Double_Precision (S_Dsave (index));
      end loop;

      setulb (Fortran_Integer (SM), X, To_DP_Array (SL), To_DP_Array (SU),
              Fortran_Integer_Array (S_Nbd), F, G, Factr, Pgtol,
              Wa, Iwa, Task_Name, Fortran_Integer (S_Iprint), Csave,
              Lsave, Isave, Dsave, Fortran_Integer (S_Maxls));

      SX := To_RF_Array (X);
      SF := Float (F);
      SG := To_RF_Array (G);
      S_Factr := Float (Factr);
      S_Pgtol := Float (Pgtol);
      S_Wa := To_RF_Array (Wa);
      S_Iwa := Integer_Array (Iwa);
      S_Task_Name := To_Unbounded_String (To_Ada (Task_Name));
      S_Csave := To_Unbounded_String (To_Ada (Csave));
      S_Lsave := LSave_Array (Lsave);
      S_Isave := Integer_Array (Isave);
      for index in Dsave'Range loop
         S_Dsave (index) := Float (Dsave (index));
      end loop;

   end Set_Ulb;

   --  -------------------------------------------------------------------------

   function To_DP_Array (RA : Real_Float_Vector) return Fortran_DP_Array is
      Result : Fortran_DP_Array (RA'Range);
   begin
      for index in RA'Range loop
         Result (index) := Double_Precision (RA (index));
      end loop;

      return Result;
   end To_DP_Array;

   --  -------------------------------------------------------------------------

   function To_RF_Array (DPA : Fortran_DP_Array) return Real_Float_Vector is
      Result : Real_Float_Vector (DPA'Range);
   begin
      for index in DPA'Range loop
         Result (index) := Float (DPA (index));
      end loop;

      return Result;

   end To_RF_Array;

   --  -------------------------------------------------------------------------

--     function Zero_Array (Num_Rows : Positive) return Fortran_DP_Array is
--        Result : Fortran_DP_Array (1 .. Num_Rows);
--     begin
--        for index in Result'Range loop
--           Result (index) := Double_Precision (0.0);
--        end loop;
--
--        return Result;
--     end Zero_Array;

   --  -------------------------------------------------------------------------

end Lbfgsb_F_Interface;
